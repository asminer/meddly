
satimpl_opname::implicit_relation* substate_varoption::buildNSF_IMPLICIT(named_msg &debug)
{
using namespace MEDDLY;
// exprman* em = getExpressionManager();
// DCASSERT(em);
substate_colls* c_pass = this->getSubstateStorage();
  
  
  for(int i = 0; i<nEvents; i++) {
    if(enable_deps[i])
      for (deplist *DL = enable_deps[i]; DL; DL=DL->next) {
        int k = DL->getLevelAbove(0);
        for ( ; k>0; k=DL->getLevelAbove(k)) { // obtaining the enabling variables from bottom to top
          printf("\n enabling variable for event %d  = ")
          std::pair<long,long> enable_alone = std::make_pair(DL->termlist->term->getLower(),0);
          event_table[i].insert(std::pair<int, std::pair<long,long>>(k,enable_alone));
        } // for k
      } // for enable_deps
    
    if(fire_deps[i])
      for (deplist *DL = fire_deps[i]; DL; DL=DL->next) {
        int k = DL->getLevelAbove(0);
        for ( ; k>0; k=DL->getLevelAbove(k)) {
          long fst = 0;
          std::map<int, std::pair<long,long>>::iterator fit = event_table[i].find(k);
          if (fit != event_table[i].end()) fst = fit->second.first;
          std::pair<long,long> fire_alone = std::make_pair(fst,DL->termlist->term->getDelta());
          event_table[i].erase(k);
          event_table[i].insert(std::pair<int, std::pair<long,long>>(k,fire_alone));
        } // for k
      } // for fire_deps
    
    max_node_count+=event_table[i].size();
    if(event_table[i].size()>0)
      {  
        std::map<int, std::pair<long,long>>::reverse_iterator rit = event_table[i].rbegin();
        tops_of_events[i] = rit->first;
      }
  }// for Events

  
  
  

satimpl_opname::implicit_relation* T = new satimpl_opname::implicit_relation(ms.getMddForest(), ms.getMddForest(), ms.getMddForest());

int max_node_count = 10;
int nEvents = getParent().getNumEvents();
// int nPlaces = getParent().getNumStateVars();


int* tops_of_events = (int*)malloc(nEvents*sizeof(int));
// int* place_count_in_event = (int*)malloc(nEvents*sizeof(int));
std::vector<std::map<int, std::pair<long,long>>> event_table;
event_table.resize(nEvents);
//Holds the variables affected in the events from bottom to top
// int** v_all_fire = (int**)malloc(nEvents*sizeof(int*));
//Holds the constant delta of event on certain variable
// long** v_delta_fire = (long**)malloc(nEvents*sizeof(int*));





derive_relation_node** rNode = (derive_relation_node**)malloc(max_node_count*sizeof(derive_relation_node*));
int rCtr = 0;
// int avbl = 0;

for(int i = 0; i < nEvents; i++)
{
unsigned long sign = 0;
int previous_node_handle = 1;
std::map<int, std::pair<long,long>>::iterator e_it = event_table[i].begin();
if(event_table[i].size()>0)
while(e_it!=event_table[i].end()){

int uniq = (e_it->first)*100 + (e_it->second.first)*10 + (e_it->second.first+e_it->second.second);
sign = sign*10 + uniq;
rNode[rCtr] = new derive_relation_node(debug,e_it->second.first,e_it->second.second,c_pass,sign,e_it->first,previous_node_handle);
previous_node_handle = T->registerNode((e_it->first==tops_of_events[i]),rNode[rCtr]);
rCtr ++;
e_it++;
}
}

//
// Return overall implicit relation
//
return T;
}
