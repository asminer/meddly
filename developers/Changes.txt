Implement next:

    * select operation, and test case for it
        -> as an iterator instead of an operation
        -> begin_random()  instead of begin() to initialize?

    RELEASE HERE PROBABLY

    * Design general purpose 'model' or 'transition relation' interface

    * Relational product operations, using new interface

    * Saturation operations, using new interface

    * Again explore mark and sweep vs reference counts
      try a 'mark and count down' approach also


Operation updates, to do:
    * re-implement operations using new CT interface
    * eventually: remove CTs from operation base class
    * eventually: remove entry registration from operation base class




======================================================================
Completely reimplemented operations
======================================================================

arith_max.cc
arith_min.cc
arith_plus.cc
arith_minus.cc
arith_mult.cc
arith_div.cc
arith_mod.cc

cardinality.cc
cross.cc
compare.cc
complement.cc
copy.cc

difference.cc
intersection.cc
maxmin_range.cc
union.cc

mdd2index.cc

======================================================================
Operations with no need for updating
======================================================================

vect_matr.cc

======================================================================
Operations that need updating
======================================================================

constrained.cc
        NO      constrained_forwd_dfs_mt
        NO      constrained_bckwd_dfs_mt
        NO      constrained_bckwd_dfs_evplus

cycle.cc
        NO      cycle_EV2EV


mm_mult.cc
        NO      mm_mult_mt

prepostimage.cc
        NO      mtmatr_mtvect
        NO      mtmatr_evplusvect
        NO      tcXrel_evplus

prepostplus.cc
        NO      preplus_evplus
        NO      postplus_evplus

reach_bfs.cc
        NO      forwd_bfs_mt
        NO      forwd_bfs_evplus
        NO      bckwd_bfs_mt
        NO      bckwd_bfs_evplus

reach_dfs.cc
        NO      forwd_dfs_mt
        NO      forwd_dfs_evplus
        NO      bckwd_dfs_mt

sat_hyb.cc
        NO      forwd_hyb_dfs_by_events_mt

sat_impl.cc
        NO      forwd_impl_dfs_by_events_mt

sat_otf.cc
        NO      forwd_otf_dfs_by_events_mt

sat_pregen.cc
        NO      forwd_dfs_by_events_mt
        NO      bckwd_dfs_by_events_mt

select.cc
        NO      select_MT
        NO      select_EVPlus

transitive_closure.cc
        NO      transitive_closure_forwd_dfs

======================================================================


Go through examples/ directory,
see if some stuff can become test cases


Files that need updating / cleanup
------------------------------------------------------------
defines.h
hash_stream.h
heap.h
impl_unique_table.h     impl_unique_table.cc
loggers.h               loggers.cc

relation_node.h         relation_node.cc


======================================================================
Non-critical to do list (side quests)
======================================================================

* unpacked nodes:
    maintain 2 different free lists, one for sparse (has index array),
    one for full.
    Go back to non-struct form, see if it is faster

* Creating functions for variables
    also functions of single variables
    currently in forest, does it belong there?
    maybe goes with sparse minterm collections?

* remove or re-design logger class

* all different operation
    intersect a function with 'this set of vars
    must be all different`.
    Limit to possible values {0, ..., 31} so we can
    use unsigned ints for the set of taken values?

* existential quantification operation
    boolean only? or describe as "max value over these vars"?

* universal quantification operation
    boolean only? or describe as "min value over these vars"?

* interval decision diagrams?

* look at using ev* over rationals to avoid floating-point issues?

