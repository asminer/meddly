Implement next:

    * Design general purpose 'model' or 'transition relation' interface

    pool of relation nodes (like forest):
        * Do we need a global relation registry, like forests?
        * unique ID for each "node"
        * zero ID always means empty relation
        * negative ID always means 'terminal node'

        * relation pool methods:
            virtual relation_node& fetchRelation(unsigned ID, bool outgoing)=0;
            virtual void doneRelation(relation_node& rn)=0;

        * abstract base class for "relation node"
            unsigned rnID;
            unsigned level;

            virtual bool outgoing(unsigned i, relslice &rs);
            virtual bool incoming(unsigned i, relslice &rs);
            // ^
            // return false if there are no outgoing/incoming edges;
            // otherwise return true.
            //
            // fill rs with the outgoing/incoming edges for value i
            // according to relation with given ID.
            // The contents of rs are undefined (likely, unchanged)
            // if the function returns false.
            //

        struct relslice {
            node_handle diagonal;
            edge_value  diag_ev;

            unsigned* index;
            node_handle* down;
            edge_value* values;
            //
            // ^ or use std::vector?
        };




    types of pools:
        * forest, for 'ordinary' MxDs
        * implicit nodes: add/subtract a constant
        * implicit nodes: generic
        * parameterized implicit nodes ?
        * AND: intersection of several IDs
            possibly also with constrained row/column sets
        * special AND for disjoint levels (e.g., a chain?)
        * OR: union of several relations


    relation (like dd_edge):
        * parent pool
        * ID of root
        * top-most non-identity level
        * which levels are non-identity


    operations:
        * allow binary operations between forest and relation



    * Relational product operations, using new interface

    * Saturation operations, using new interface

    * Again explore mark and sweep vs reference counts
      try a 'mark and count down' approach also


Operation updates, to do:
    * re-implement operations using new CT interface
    * eventually: remove CTs from operation base class
    * eventually: remove entry registration from operation base class




======================================================================
Completely reimplemented operations
======================================================================

arith_max.cc
arith_min.cc
arith_plus.cc
arith_minus.cc
arith_mult.cc
arith_div.cc
arith_mod.cc

cardinality.cc
cross.cc
compare.cc
complement.cc
copy.cc

difference.cc
intersection.cc
maxmin_range.cc
union.cc

mdd2index.cc

======================================================================
Operations with no need for updating
======================================================================

select.cc       -> DEPRECATED

vect_matr.cc

======================================================================
Operations that need updating
======================================================================

constrained.cc
        NO      constrained_forwd_dfs_mt
        NO      constrained_bckwd_dfs_mt
        NO      constrained_bckwd_dfs_evplus

cycle.cc
        NO      cycle_EV2EV


mm_mult.cc
        NO      mm_mult_mt

prepostimage.cc
        NO      mtmatr_mtvect
        NO      mtmatr_evplusvect
        NO      tcXrel_evplus

prepostplus.cc
        NO      preplus_evplus
        NO      postplus_evplus

reach_bfs.cc
        NO      forwd_bfs_mt
        NO      forwd_bfs_evplus
        NO      bckwd_bfs_mt
        NO      bckwd_bfs_evplus

reach_dfs.cc
        NO      forwd_dfs_mt
        NO      forwd_dfs_evplus
        NO      bckwd_dfs_mt

sat_hyb.cc
        NO      forwd_hyb_dfs_by_events_mt

sat_impl.cc
        NO      forwd_impl_dfs_by_events_mt

sat_otf.cc
        NO      forwd_otf_dfs_by_events_mt

sat_pregen.cc
        NO      forwd_dfs_by_events_mt
        NO      bckwd_dfs_by_events_mt

transitive_closure.cc
        NO      transitive_closure_forwd_dfs

======================================================================


Go through examples/ directory,
see if some stuff can become test cases


Files that need updating / cleanup
------------------------------------------------------------
hash_stream.h
heap.h
impl_unique_table.h     impl_unique_table.cc
loggers.h               loggers.cc

relation_node.h         relation_node.cc

======================================================================
Long-term forest plan
======================================================================
* After forest derived classes are eliminated
* After reference counts are eliminated in favor of mark & sweep
* Generic "forest" class, base of current forest and relforest classes
* What are the essential features of a forest?
    + Create, destroy forests
    + Might have CT entries
    + Node handles <= 0 are for terminals
    + Node handles > 0 are for "real nodes"

    + Range
    + Edge labelings
    + Set/relation

    + Level of a handle?

    + boolean - can it provide an unpacked node?
    + virtual method to provide an unpacked node
      (default: throw INVALID_OPERATION)

    + boolean - can it provide a relation node?
    + virtual method to provide a relation node

    + names - "vector node" vs "matrix node"?

    + common "node header" stuff?
        mark byte
        level
        storage address (unsigned or unsigned long? relative to level?)

    + common functionality?
        request unused handle
        mark a handle and its children
        check if a handle is marked
        sweep - need a call back to delete an address

        global forest registry



======================================================================
Non-critical to do list (side quests)
======================================================================

* unpacked nodes:
    maintain 2 different free lists, one for sparse (has index array),
    one for full.
    Go back to non-struct form, see if it is faster

* Creating functions for variables
    also functions of single variables
    currently in forest, does it belong there?
    maybe goes with sparse minterm collections?

* remove or re-design logger class

* all different operation
    intersect a function with 'this set of vars
    must be all different`.
    Limit to possible values {0, ..., 31} so we can
    use unsigned ints for the set of taken values?

* existential quantification operation
    boolean only? or describe as "max value over these vars"?

* universal quantification operation
    boolean only? or describe as "min value over these vars"?

* interval decision diagrams?

* look at using ev* over rationals to avoid floating-point issues?

