
Implement next, using new rel_node interface:

    * pre/post image on EV+

    * User-defined element-wise unary functions
        virtual void F(const rangeval &in, rangeval &out) const;

        constructor     user_unary(range_type intype, range_type outtype);
        // name?

        // automatically determined by checking F(0) == 0
        inline bool preserves_zero() const;
        // if true we can use sparse nodes in apply()
        // also might allow us to skip identities

        stuff to try
            ABS(x)      // preserves zero
            NEG(x)      // preserves zero
            INCNNEG(x) = { x+1, if x>=0; -1 otherwise }


    * DISTUPDATE operation
        element-wise distance update.
        Given integers or reals a,b:
            if a<0 and b<0, return -1
            if a>=0 and b>=0, return MIN(a, b)
            if a<0 and b>=0, return b
            if b<0 and a>=0, return a
        Useful for distance computation for MT, with -1 for unreachable.


    * pre/post image on MT with negative for unreachable :)

    * vect/matr and matr/vect multiplication tests
        (now within pre/post image)

========= (release?)

    * bfs with frontier sets.
        as an operation?
        or as a function?
        need ability to provide call-backs so we can display (or not)
            information after each iteration.

    * bfs without frontier sets.

========= (release?)

    * saturation 1 monolithic relation
        states only
        distances

========= (release?)

    * saturation 2 monolithic relation
        'saturate after' but on diagonal
        states only
        distances

    * saturation 3 monolithic relation
        'saturate before'
        states only
        distances

========= (release?)

    * ability to store other relation nodes inside a forest
        (ugly implementation internally is fine)

    * AND/OR nodes

    * constraint nodes - for 'constrained saturation'

    * implicit nodes
        + enabled if low <= i < high
             (0==high for high = infinity?)

        + add a constant delta (could be negative)


    * user-defined implicit nodes
        + provide a function, f(i) gives j and down pointer?
        + need level, and hash
        + should work fine for OTF saturation

    * user-defined multi-level implicit nodes
        + interface ?
            - set of levels k1, ..., kn, as inputs
            - single level k0, as output
            - provide a function, f(i_k1, i_k2, ..., i_kn) = j_k0
            - enlarge one of the kc levels

        + how to efficiently use this?
            - automatically build MxD underneath?

========= (release?)

    * pre/post image on relations (e.g. transitive closure)
        and test programs
        states only
        distances

    * saturation 1, 2, 3 on relations
        states only
        distances


========= (release?)

    * updated mark and sweep with counters

    * try to eliminate reference counting altogether

    * simplify node headers and release

    * Protected nodes
        very light dd_edge for mark and sweep registry

        constructor:    register itself
        destructor:     unregister itself
        override = and such
        keep track of index for fast unregister

        forest: vector of pointers to protected nodes

========= (release?)

    * new byte-based node storage
        first and last byte: storage type
            0: small hole (less than 256 bytes)
            1: large hole (more than 256 bytes)

            2..: specifies which codec to use for node storage

            codecs are registered but otherwise agnostic to node storage.
            codec table keeps track of
                constants a and b, the number of bytes for a node
                is a * size + b. If a==0 then we don't need to store a size.


            examples:
            BDD, d-byte down, e-byte EV
                a = 0, b = 2*d + e  (assuming normalized)

                use d in { 2, 4, 6 } and e in { 1, 2, 4, 8 }.
                (e = 1 for REXBDDs)

            12 combos


            truncated full storage, s-byte size, d-byte down, e-byte EV
                a = d+e, b = s

                use s in { 1, 2, 3 },
                    d in { 2, 4, 6 },
                    e in { 2, 4, 8 }.

            27 combos

            sparse storage, s-byte size and index, d-byte down, e-byte EV
                a = s+d+e, b = s

                use s in { 1, 2, 3 },
                    d in { 2, 4, 6 },
                    e in { 2, 4, 8 }.

            27 combos


            AND/OR nodes, b-byte size, a-byte down

                use b in { 1, 2 },
                    a in { 2, 4, 6 }

            6 combos


            implicit nodes, d-byte low, high, delta (signed)
                a = 0, b = 3d

                use d in { 1, 2, 4 }

            3 combos





=====================================================================
    How to integrate relation nodes into forests?

        reading: node handle to rel_node

        writing: ?
            develop interface for node_manager
            possibilities are:
                * stored as nodes at 2 levels as usual
                * compacted into 1 level
                * stored externally

        mark and sweep and whatnot:
            fill in a vector of downward pointers


=====================================================================


    * Add 'relation node' construction from forests
        + forest contains free list of rel_nodes?

        + allow address in node header to be optional
            (missing means 'address' is equal to node handle)

        + allow node manager to be optional
            (implicit node forests use null pointers here)



    pool of relation nodes (like forest):
        * Do we need a global relation registry, like forests?
        * unique ID for each "node"
        * zero ID always means empty relation
        * negative ID always means 'terminal node'

        * relation pool methods:
            virtual relation_node& fetchRelation(unsigned ID, bool outgoing)=0;
            virtual void doneRelation(relation_node& rn)=0;

        * abstract base class for "relation node"
            unsigned rnID;
            unsigned level;

            virtual bool outgoing(unsigned i, relslice &rs);
            virtual bool incoming(unsigned i, relslice &rs);
            // ^
            // return false if there are no outgoing/incoming edges;
            // otherwise return true.
            //
            // fill rs with the outgoing/incoming edges for value i
            // according to relation with given ID.
            // The contents of rs are undefined (likely, unchanged)
            // if the function returns false.
            //

        struct relslice {
            node_handle diagonal;
            edge_value  diag_ev;

            unsigned* index;
            node_handle* down;
            edge_value* values;
            //
            // ^ or use std::vector?
        };




    types of pools:
        * forest, for 'ordinary' MxDs
        * implicit nodes: add/subtract a constant
        * implicit nodes: generic
        * parameterized implicit nodes ?
        * AND: intersection of several IDs
            possibly also with constrained row/column sets
        * special AND for disjoint levels (e.g., a chain?)
        * OR: union of several relations


    relation (like dd_edge):
        * parent pool
        * ID of root
        * top-most non-identity level
        * which levels are non-identity


    operations:
        * allow binary operations between forest and relation



    * Relational product operations, using new interface

    * Saturation operations, using new interface

        - check timing: overhead for rel_node objects

===========
    release here?
===========

    * Split forest into 'node reading' portion
        and derived class (dd_forest) with 'node writing' portion.

    * Add some implicit relation forests with node readers


    * Again explore mark and sweep vs reference counts
      try a 'mark and count down' approach also


Operation updates, to do:
    * re-implement operations using new CT interface
    * eventually: remove CTs from operation base class
    * eventually: remove entry registration from operation base class


======================================================================
Mark and sweep stuff
======================================================================
    * need roots for marking
    * Mark phase: mark roots and their descendants
    * Sweep CTs: remove any entry with an unmarked node in key or result
    * Sweep nodes: remove unmarked nodes; decrement mark for all others

======================================================================
Completely reimplemented operations
======================================================================

arith_max.cc
arith_min.cc
arith_plus.cc
arith_minus.cc
arith_mult.cc
arith_div.cc
arith_mod.cc

cardinality.cc
cross.cc
compare.cc
complement.cc
copy.cc

difference.cc
intersection.cc
maxmin_range.cc

reach_bfs.cc
union.cc

mdd2index.cc

======================================================================
Operations with no need for updating
======================================================================

select.cc       -> DEPRECATED

vect_matr.cc

======================================================================
Operations that need updating
======================================================================

constrained.cc
        NO      constrained_forwd_dfs_mt
        NO      constrained_bckwd_dfs_mt
        NO      constrained_bckwd_dfs_evplus

cycle.cc
        NO      cycle_EV2EV


mm_mult.cc
        NO      mm_mult_mt

prepostimage.cc
        NO      mtmatr_mtvect
        NO      mtmatr_evplusvect
        NO      tcXrel_evplus

prepostplus.cc
        NO      preplus_evplus
        NO      postplus_evplus

reach_dfs.cc
        NO      forwd_dfs_mt
        NO      forwd_dfs_evplus
        NO      bckwd_dfs_mt

sat_hyb.cc
        NO      forwd_hyb_dfs_by_events_mt

sat_impl.cc
        NO      forwd_impl_dfs_by_events_mt

sat_otf.cc
        NO      forwd_otf_dfs_by_events_mt

sat_pregen.cc
        NO      forwd_dfs_by_events_mt
        NO      bckwd_dfs_by_events_mt

transitive_closure.cc
        NO      transitive_closure_forwd_dfs

======================================================================


Go through examples/ directory,
see if some stuff can become test cases


Files that need updating / cleanup
------------------------------------------------------------
hash_stream.h
heap.h
impl_unique_table.h     impl_unique_table.cc
loggers.h               loggers.cc

relation_node.h         relation_node.cc

======================================================================
Long-term forest plan
======================================================================
* After forest derived classes are eliminated
* After reference counts are eliminated in favor of mark & sweep
* Generic "forest" class, base of current forest and relforest classes
* What are the essential features of a forest?
    + Create, destroy forests
    + Might have CT entries
    + Node handles <= 0 are for terminals
    + Node handles > 0 are for "real nodes"

    + Range
    + Edge labelings
    + Set/relation

    + Level of a handle?

    + boolean - can it provide an unpacked node?
    + virtual method to provide an unpacked node
      (default: throw INVALID_OPERATION)

    + boolean - can it provide a relation node?
    + virtual method to provide a relation node

    + names - "vector node" vs "matrix node"?

    + common "node header" stuff?
        mark byte
        level
        storage address (unsigned or unsigned long? relative to level?)

    + common functionality?
        request unused handle
        mark a handle and its children
        check if a handle is marked
        sweep - need a call back to delete an address

        global forest registry



======================================================================
Non-critical to do list (side quests)
======================================================================

* unpacked nodes:
    maintain 2 different free lists, one for sparse (has index array),
    one for full.
    Go back to non-struct form, see if it is faster

* Creating functions for variables
    also functions of single variables
    currently in forest, does it belong there?
    maybe goes with sparse minterm collections?

* remove or re-design logger class

* all different operation
    intersect a function with 'this set of vars
    must be all different`.
    Limit to possible values {0, ..., 31} so we can
    use unsigned ints for the set of taken values?

* existential quantification operation
    boolean only? or describe as "max value over these vars"?

* universal quantification operation
    boolean only? or describe as "min value over these vars"?

* interval decision diagrams?

* look at using ev* over rationals to avoid floating-point issues?

