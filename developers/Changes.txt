
Implement next:

    * Comparisons for EV+, EV*
        + add test cases to ops_comp

    RELEASE HERE



    * super combined element-wise arithmetic into 1-3 mega operations
        like we did for comparisons. Templatized using class with
        inlined static methods.

        For multi-terminal:

            // name for display purposes
            const char* name();

            // does the operation commute, a OP b always equals b OP a
            bool commutes();

            // does the given value act as an identity
            // as the first operand: does x OP ? = ?
            bool isLeftIdentity(node_handle x);

            // does the given value act as an identity
            // as the second operand: does ? OP x = ?
            bool isRightIdentity(node_handle x);

            // Apply on terminals
            node_handle applyTerminals(const forest* fa, node_handle a,
                            const forest* fb, node_handle b);



        For "compatible" operators with the EV operator
            (e.g., + or - on EV+; * or / on EV* )

            // name for display purposes
            const char* name();

            // does the operation commute?
            // this means its the same operation.
            bool commutes();

            // does the given edge value act as an identity
            // as the second operand (also first, if we commute)
            bool isIdentity(const edge_value& ev);

            // Apply on two edge values
            // c = a op b
            applyEV(const edge_value &a, const edge_value &b, edge_value &c);


            // For EV+ we can always strip off edge values:
            //
            //      (av + an()) - (bv + bn()) =
            //      av-bv + an()-bn()
            //
            //      (av + an()) + (bv + bn()) =
            //      av+bv + an()+bn()
            //

            // For EV* we can always strip off edge values:
            //
            //      (av * an()) / (bv * bn()) =
            //      (av / bv) * (an() / bn())
            //
            //      (av * an()) * (bv * bn()) =
            //      (av * bv) * (an() * bn())
            //


        For "factoring" operators w.r.t. the EV operator
            (e.g., + or - on EV*; max or min on EV+)

            // We can factor common EV out, meaning we can
            // always normalize so that the first edge value is identity.
            //
            // (av * an()) + (bv * bn()) =
            // av * [ (1 * an()) + (bv/av * bn()) ]
            //
            // (av + an()) max (bv + bn()) =
            // av + [ (0 + an()) max (bv-av + bn()) ]
            //


        For "push down" operators


        Operators: plus, minus, divide, multiply, modulo, max, min




Current goal:
    * Better centralized omega meanings
    * Use 0 handle for "normal" omega, non-zeroes for special values
        (could break lots of things)

    * use COPY operation where it makes sense, e.g.,
        terminal cases in cross-forest unions


Interface changes (aside from moving header files around)
======================================================================

Make compute table interface easier to use for simple operations
    (i.e., most of the time)

Updates to operation interface:

    * Add a 'temporary' node handle in unpacked_node,
      will be marked during mark and sweep

    * Allow (back) low-level interface


Operation updates, to do:
    * re-implement operations using new CT interface
        start with intersection and check timing

    * eventually: remove CTs from operation base class
    * eventually: remove entry registration from operation base class



Next release:

Finish Reimplementing operations.


======================================================================

generic EV 'operator' for edges should provide:

    // Combine edge values a and b, store result in c
    static inline void apply(const edge_value &a, const edge_value &b,
        edge_value &c);

    // Combine edge values a and b, store result in a
    static inline void update(edge_value &a, const edge_value &b);

    // "Clear" an edge value; i.e., make it the identity element
    static inline void clear(edge_value &a);

======================================================================
Completely reimplemented operations
======================================================================

cardinality.cc      yes
compare.cc          yes
complement.cc       yes
copy.cc             yes

difference.cc       yes
intersection.cc     yes         tbd: evplus (move to max)
maxmin_range.cc     yes
union.cc            yes         tbd: evplus (move to min)

======================================================================
Operations that need updating
======================================================================

constrained.cc
        NO      constrained_forwd_dfs_mt
        NO      constrained_bckwd_dfs_mt
        NO      constrained_bckwd_dfs_evplus

cross.cc
        NO      cross_bool

cycle.cc
        NO      cycle_EV2EV


divide.cc
        NO      divide_mdd
        NO      divide_mxd

maxmin.cc
        NO      maximum_mdd
        NO      maximum_mxd
        NO      minimum_mdd
        NO      minimum_mxd

mdd2index.cc
        NO      mdd2index_operation

minus.cc
        NO      minus_mdd
        NO      minus_mxd
        NO      minus_evplus
        NO      minus_evtimes

mm_mult.cc
        NO      mm_mult_mt

modulo.cc
        NO      modulo_mdd
        NO      modulo_mxd

multiply.cc
        NO      multiply_mdd
        NO      multiply_mxd
        NO      multiply_evplus
        NO      multiply_evtimes

plus.cc
        NO      plus_mdd
        NO      plus_mxd
        NO      plus_evplus
        NO      plus_evtimes

prepostimage.cc
        NO      mtmatr_mtvect
        NO      mtmatr_evplusvect
        NO      tcXrel_evplus

prepostplus.cc
        NO      preplus_evplus
        NO      postplus_evplus

reach_bfs.cc
        NO      forwd_bfs_mt
        NO      forwd_bfs_evplus
        NO      bckwd_bfs_mt
        NO      bckwd_bfs_evplus

reach_dfs.cc
        NO      forwd_dfs_mt
        NO      forwd_dfs_evplus
        NO      bckwd_dfs_mt

sat_hyb.cc
        NO      forwd_hyb_dfs_by_events_mt

sat_impl.cc
        NO      forwd_impl_dfs_by_events_mt

sat_otf.cc
        NO      forwd_otf_dfs_by_events_mt

sat_pregen.cc
        NO      forwd_dfs_by_events_mt
        NO      bckwd_dfs_by_events_mt

select.cc
        NO      select_MT
        NO      select_EVPlus

transitive_closure.cc
        NO      transitive_closure_forwd_dfs

union.cc
        tbd     union_mt    (combines old union_mdd and union_mxd)

        YES*    union_mdd
        YES*    union_mxd
        NO      union_min_evplus
        NO      union_min_evplus_mxd

vect_matr.cc
        N/A     VM_evplus_mt
        N/A     MV_evplus_mt

======================================================================


Go through examples/ directory,
see if some stuff can become test cases


Files that need updating / cleanup
------------------------------------------------------------
defines.h
enumerator.h            enumerator.cc
hash_stream.h
heap.h
impl_unique_table.h     impl_unique_table.cc
loggers.h               loggers.cc

relation_node.h         relation_node.cc


======================================================================
Non-critical to do list (side quests)
======================================================================
* Minterm collections, unioning with existing sets
    full / sparse minterms
    sets / relations

* Evaluation by overloading() on dd_edge?
    Using a single minterm? Or vector of integers?

* Enumeration
    Tie to evaluation?
    Have 'fixed' variables and 'free' variables
        all fixed: evaluation
        all free:  old enumeration
        primed / unprimed are fixed: like old row / col enumerators

    Fixed levels: use full unpacked
    Free levels : use sparse unpacked

* Creating functions for variables
    also functions of single variables
    currently in forest, does it belong there?
    maybe goes with sparse minterm collections?

* all different operation
    intersect a function with 'this set of vars
    must be all different`.
    Limit to possible values {0, ..., 31} so we can
    use unsigned ints for the set of taken values?

* existential quantification operation
    boolean only? or describe as "max value over these vars"?

* universal quantification operation
    boolean only? or describe as "min value over these vars"?

* interval decision diagrams?

* look at using ev* over rationals to avoid floating-point issues?

