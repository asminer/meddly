
Interface changes (aside from moving header files around)
======================================================================

Forest cleanup
    look at node reductions

Operations
        -> split out and simplify (templates and functors) the
            apply_generic_mdd style classes
                (goal is for 'check terminals' to be inlined, not virtual)


(*) operation registry in a forest - timing test

(*) node_storage::getDownPtr timing test

(*) One version of node_storage::getDownPtr, using edge_value

(*) new operations (leave old in place until deprecated)

    builtins are function (pointers) but now use arguments
        instead of the 'named operation' class.
        e.g.,

        new_binary* INTERSECTION(forest* op1, forest* op2, forest* result)

    stuff we will probably want/need
        -   some kind of builtin initializer object that automatically
            builds a list of operations to initialize / destroy,
            and fit that into the current library init/destroy sequence.

        -   for each type of operation (e.g., intersection), maintain
            a list (or vector?) of instantiated operations.
            could use list of unsigned, assuming there is a global
            unique ID for operations that is reset on library init/destroy.
            if so then the builtin functions can return unsigned instead
            of new_binary*.

        -   new operation hierarchy, or adjust existing one?
            some thoughts:
                operation
                    |
                    +--- binary_operation
                            |
                            +---- binary skip levels
                            |           inline void compute_top(
                            |               const dd_edge &a,
                            |               const dd_edge &b, dd_edge c)
                            |
                            |           node_handle compute(node_handle a,
                            |               node_handle b)
                            |
                            +---- binary by levels (for quasi reduced results)
                            |
                            |           node_handle compute(int K,
                            |               node_handle a, node_handle b)
                            |
                            +---- binary, EV, skip levels
                            |
                            |           compute(const edge_value &av,
                            |               node_handle an, const edge_value &,
                            |               node_handle bn, edge_value &ec,
                            |               node_handle &cn)
                            |
                            |           We could use the same iface for MT
                            |           using void edge values, see if there's
                            |           overhead and if so keep them split.
                            |
                            +---- binary, EV, by levels





(*) binary operations:

    * change interface to use edge_value, node_handle instead of dd_edge
    * keep dd_edge version as inlined


Go through examples/ directory,
see if some stuff can become test cases


Files that need updating / cleanup
------------------------------------------------------------
defines.h
enumerator.h            enumerator.cc
forest.h                forest.cc
hash_stream.h
heap.h
impl_unique_table.h     impl_unique_table.cc
loggers.h               loggers.cc
memory.h                memory.cc
opname.h                opname.cc
opname_numer.h          opname_numer.cc
opname_satur.h          opname_satur.cc

oper.h                  oper.cc
oper_binary.h           oper_binary.cc
oper_unary.h            oper_unary.cc

relation_node.h         relation_node.cc


======================================================================
Non-critical to do list (side quests)
======================================================================
* Minterm collections, unioning with existing sets
    full / sparse minterms
    sets / relations

* Evaluation by overloading() on dd_edge?
    Using a single minterm? Or vector of integers?

* Enumeration
    Tie to evaluation?
    Have 'fixed' variables and 'free' variables
        all fixed: evaluation
        all free:  old enumeration
        primed / unprimed are fixed: like old row / col enumerators

    Fixed levels: use full unpacked
    Free levels : use sparse unpacked

* Creating functions for variables
    also functions of single variables
    currently in forest, does it belong there?
    maybe goes with sparse minterm collections?

* all different operation
    intersect a function with 'this set of vars
    must be all different`.
    Limit to possible values {0, ..., 31} so we can
    use unsigned ints for the set of taken values?

* existential quantification operation
    boolean only? or describe as "max value over these vars"?

* universal quantification operation
    boolean only? or describe as "min value over these vars"?

* interval decision diagrams?
