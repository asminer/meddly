
Interface changes (aside from moving header files around)
======================================================================


Make compute table interface easier to use for simple operations
    (i.e., most of the time)

    * compute table item class, like edge value class
        type, and a union

Compute table entry types
    * should have a compute table
            + their own, for non-monolithic
            + the global one, for monolithic

    * allow ct entry registration directly in CTs

    * ct entry registry: static in CT or not?
            + if not, then non-monolithic CTs will
              have single entry 'registry'

    * eventually: remove CTs from operation base class
    * eventually: remove entry registration from operation base class


Compute table ideas
    *   ct_vector   packing and unpacking operations
                    packing area is at most an unsigned long per item,
                    possibly plus one.

                    'none'
                        : just copy over
                    'type based'
                        : use slots of unsigned, each item (by type)
                          will use one or two slots
                    'value based'
                        : use slots of unsigned short, each item
                          will use 1-4 slots by value
                            0..2^16-1   1 slot
                             ..2^32-1   2 slots
                             ..2^48-1   3 slots
                             ..2^64-1   4 slots
                          but then we need 2 bits per item,
                          need to figure out where to store those.
                          Don't implement this yet but design
                          stuff so that adding this is not horrible.

        The packed version is what's stored, so we can check for
        equality very easily in the CT then
        (i.e., does that account for the time difference between
        ct_none and ct_typebased?)


Next release:

Reimplement operations.

Depending on how that goes, maybe adjust the operation hierarchy?

        some thoughts:
            operation
                |
                +--- binary_operation
                        |
                        +---- binary skip levels
                        |           inline void compute_top(
                        |               const dd_edge &a,
                        |               const dd_edge &b, dd_edge c)
                        |
                        |           node_handle compute(node_handle a,
                        |               node_handle b)
                        |
                        +---- binary by levels (for quasi reduced results)
                        |
                        |           node_handle compute(int K,
                        |               node_handle a, node_handle b)
                        |
                        +---- binary, EV, skip levels
                        |
                        |           compute(const edge_value &av,
                        |               node_handle an, const edge_value &,
                        |               node_handle bn, edge_value &ec,
                        |               node_handle &cn)
                        |
                        |           We could use the same iface for MT
                        |           using void edge values, see if there's
                        |           overhead and if so keep them split.
                        |
                        +---- binary, EV, by levels


Although, if we make compute tables easy enough to use, then
the motivation for abstract apply operation implementation goes away.

Ideal:
    class union : public binary_operation {
        // ...
        private:
            ct_entry_type* CTE;
    };

    union::union(owner, fa1, fa2, fres)
        : binary_operation(owner, fa1, fa2, fres)
    {
        CTE = new ct_entry_type("union");
        //        ^
        //        This now also builds the CT (or uses the monolithic one)
        //        for this entry and calls it automatically.
        //        The entry is automatically registered with the CT.
        CTE->setFixed(fa1, fa2);
        CTE->setResult(fres);
    }

    union::~union()
    {
        delete CTE;
        //     ^
        //     unregisters with its CT automatically.
        //     if the CT is not monolithic, it's also destroyed
    }

    void union::compute(node_handle a, node_handle b, node_handle &c)
    {
        if (0==a) return b;
        if (0==b) return a;
        if (1==a) return 1;
        if (1==b) return 1;
        if (a==b) return a; // same forest only

        commute_order(a, b);    // if we can commute, make sure a<b

        ct_vector key(2), result(1);

        key[0].setN(a);
        key[1].setN(b);

        if (CTE->find(key, result)) {
            c = result[0].getN();
            return;
        }

        // do computation with answer stored in c

        result[0].setN(c);
        CTE->addEntry(key, result);
    }



Forest cleanup
    look at node reductions

Operations
        -> split out and simplify (templates and functors) the
            apply_generic_mdd style classes
                (goal is for 'check terminals' to be inlined, not virtual)


(*) node_storage::getDownPtr timing test

(*) One version of node_storage::getDownPtr, using edge_value





Go through examples/ directory,
see if some stuff can become test cases


Files that need updating / cleanup
------------------------------------------------------------
defines.h
enumerator.h            enumerator.cc
forest.h                forest.cc
hash_stream.h
heap.h
impl_unique_table.h     impl_unique_table.cc
loggers.h               loggers.cc
memory.h                memory.cc
opname.h                opname.cc
opname_numer.h          opname_numer.cc
opname_satur.h          opname_satur.cc

oper.h                  oper.cc
oper_binary.h           oper_binary.cc
oper_unary.h            oper_unary.cc

relation_node.h         relation_node.cc


======================================================================
Non-critical to do list (side quests)
======================================================================
* Minterm collections, unioning with existing sets
    full / sparse minterms
    sets / relations

* Evaluation by overloading() on dd_edge?
    Using a single minterm? Or vector of integers?

* Enumeration
    Tie to evaluation?
    Have 'fixed' variables and 'free' variables
        all fixed: evaluation
        all free:  old enumeration
        primed / unprimed are fixed: like old row / col enumerators

    Fixed levels: use full unpacked
    Free levels : use sparse unpacked

* Creating functions for variables
    also functions of single variables
    currently in forest, does it belong there?
    maybe goes with sparse minterm collections?

* all different operation
    intersect a function with 'this set of vars
    must be all different`.
    Limit to possible values {0, ..., 31} so we can
    use unsigned ints for the set of taken values?

* existential quantification operation
    boolean only? or describe as "max value over these vars"?

* universal quantification operation
    boolean only? or describe as "min value over these vars"?

* interval decision diagrams?

* look at using ev* over rationals to avoid floating-point issues?

