
Plan for this branch (testing after each big step):
----------------------------------------------------------------------

(1) Switch to minimalist dd_edges

    (v) forests need to implement addRoot and removeRoot
        reference counting: just link, unlink nodes
        mark & sweep: conceptually, an array of 'root counts'
            for each node; will be sparse though.  (use std::map)

    (v) binary operators +, +=, &=, etc
        move to operators.h/.cc, check for same forests

    (v) remove getCardinality() since apply is almost as easy

    (v) change show() method: no verbosity argument,
        use showGraph() to display the graph.

    (v) overload << so we can do output << dd_edge

    (v) Use forest ID instead of pointer
        Forest IDs must be unique forever


    ( ) go back to array of pointers to dd_edges in forests;
        remove the roots map

(2) Add method

        forest::reduceUnpacked(unpacked_node *un, dd_edge &e);

    maybe virtual (if derived classes handle edges differently?)


(3) Unpacked nodes become arrays of dd_edges

(4) dd_edges keep track of which level the edge starts from
    (needed for quasi reduced)

(5) Apply implementations use dd_edges

(6) Compute tables use dd_edges

(7) How to handle dd_edges whose forest was deleted?
    Some options:
        (a) Use shared_ptr
        (b) Do it ourself: forests have reference counts

